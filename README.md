In order to compile and run from the command line, navigate to the directory containing the program with the "cd" command, then run "javac thankyou.java" followed by "java thankyou". For #2, run "javac temperature.java" followed by "java temperature".

#1 fails as the strategy the servants use resembles a typical linked list without safely being able to concurrently access it. For instance, if a servant was about to add a present to a certain location in the list, but another servant removed that present's successor at the same time, the removing servant may not notice that a present has been added, and link the wrong predecessor to the removed present's successor. This will cause the added present to be lost, which explains why the servants realized they added more presents than the number of thank you notes written. The correct strategy for #1 is to use the concurrent lock-free list implementation from the textbook. This is an efficient and thread-safe solution that ensures that the minotaur's servants can quickly get through all the presents without any errors, principally by checking the predecessor before performing operations to ensure it is valid, among other optimizations. 

On each iteration of each thread, one operation is chosen at random, either adding a present, removing it, or checking if the list contains it. For adds, a random present is chosen that has not been previously chosen (done with a ConcurrentHashMap used as a HashSet) and added to the list, until an atomic counter variable tracking how many presents have been added hits the specified limit. Another ConcurrentHashMap is present to track the presents actively in the list - this is used to generate which presents to possibly remove by converting it to a set and picking a random present from the set. The program ends when an atomic counter variable tracking how many thank you notes have been written reaches the intended number. As this is a thread-safe list, it will produce the correct solution despite multiple servant threads utilizing the same list. The lock-free nature of the list provides a significant enhancement to performance - 500,000 presents with 4 servants typically runs in about 6-8 seconds, and this performance is also boosted by ensuring that only presents that are in the list can be generated for removal. There will also be no deadlock or starvation issues due to the use of the lock-free list - the program is wait-free as there are only a limited number of presents that can be added, so all calls will eventually succeed.

My solution for #2 represents each temperature sensor as a thread. Each thread runs for 60 iterations, generating and storing a new temperature value in each of these minutes, and adds these values to PriorityBlockingQueues that are eventually used to find the maximum and minimum temperatures recorded in that hour, as well as adding every 10 minute difference in order to find the maximum 10 minute difference in that hour. Once the thread finishes all 60 measurements, an atomic counter is incremented and the thread waits. An outside thread, when the atomic counter reaches the number of active threads (8), prints out the reports and calls notify() on all threads, allowing them to proceed to the next iteration. The use of these thread-safe data structures ensures the correctness of the solution. While the use of wait() lowers the efficiency of the program, it also guarantees that no measurements will be missed as all threads will always be computing the same hour's measurements, and the program still runs in well under 1 second for 8 sensors. In terms of progress guarantees, there is no situation in which a thread could become stuck waiting for another thread to complete, barring any exceptions being thrown causing a thread to fail.


In doing this assignment, I extensively used code from the class textbook as well as reviewing the Java API.